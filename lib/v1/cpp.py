import os

import cgen as c

from .boxes import *
from .boxes_cpp import *
from .generator import Generator


WARNING = """
    This file is autogenerated via IDL, DO NOT modify it directly
    All changes will be overwritten, modify .idl files instead

"""

class File(object):
    def __init__(self, namespace=['rpc']):
        self.header = c.Block()
        self.forward = c.Block()
        self.source = c.Block()
        self.namespace = namespace

    def ns(self, parent):
        ns = c.Collection([c.Line(f'namespace {self.namespace[0]}')])
        parent.append(ns)

        if len(self.namespace) > 1:
            block = c.Block([
                c.Line(f'namespace {self.namespace[1]}')
            ])
            ns.append(block)
            return block

        return parent

    def dump(self, forward, source_includes):
        header = c.Collection(
            [c.MultilineComment(WARNING)] + 
            [c.Line('#pragma once')] +
            [c.Line(x) for x in forward]
        )
        ns = self.ns(header)

        if self.forward.contents:
            ns.append(self.forward)
            ns = self.ns(header)
        
        ns.append(self.header)
        
        source = c.Collection(
            [c.MultilineComment(WARNING)] + 
            [c.Line(x) for x in source_includes]
        )
        ns = self.ns(source)
        ns.append(self.source)
        return header, source


class CppGenerator(Generator):
    def __init__(self, *args):
        super(CppGenerator, self).__init__(*args)

        self.TRIVIAL_TYPES['int8'] = 'int8_t'
        self.TRIVIAL_TYPES['int16'] = 'int16_t'
        self.TRIVIAL_TYPES['int32'] = 'int32_t'
        self.TRIVIAL_TYPES['int64'] = 'int64_t'
        self.TRIVIAL_TYPES['uint8'] = 'uint8_t'
        self.TRIVIAL_TYPES['uint16'] = 'uint16_t'
        self.TRIVIAL_TYPES['uint32'] = 'uint32_t'
        self.TRIVIAL_TYPES['uint64'] = 'uint64_t'
        self.TRIVIAL_TYPES['float'] = 'float'
        self.TRIVIAL_TYPES['double'] = 'double'
        self.TRIVIAL_TYPES['bool'] = 'bool'
        self.VALID_TYPES['string'] = 'std::string'
        self.VALID_TYPES['vector'] = 'std::vector'

        self.structs = File()
        self.rpc = File()
        self.rpc_detail = File(namespace=['rpc', 'detail'])
        self.marshal = File(namespace=['rpc', 'marshal'])
        self.queues = File()
        self.opcodes = File()
        self.queues = File()

    def _packet_type(self):
        return 'Packet::Ptr'

    def _data_cref(self, dtype, name):
        return c.Const(c.Reference(c.Value(dtype, name)))

    def _pointer_type(self, dtype, name):
        return c.Pointer(c.Value(dtype, name))

    def _data_object_ref(self, dtype, name):
        return c.Reference(c.Value(dtype, name))

    def _data_value_ref(self, dtype, name):
        return c.Reference(c.Value(dtype, name))

    def _template_call(self, name, args):
        return f'template {name}<{", ".join(args)}>'

    def _template_function_declaration(self, template, body):
        return c.Template(template, body)

    def _template_function_name(self, template, name):
        return name

    def _template_function_arg(self, dtype, name, default=''):
        return c.Value(f'{dtype}&&...', name)

    def _template_forward(self, template, name):
        return f'std::forward<{template}>({name})...'

    def _call_queue(self, queue, args):
        args = ', '.join(args)
        name = f'_{queue.name.eval().lower()}'
        
        if queue.specifier.queue_type == QueueSpecifierType.ARRAY:
            idx = queue.specifier.args.eval()
            return f'get_superpacket(client)->send{name}<{idx}({args})'

        return f'get_superpacket(client)->send{name}({args})'

    def _pointer_call(self, obj, call):
        return f'{obj}->{call}'

    def _ns_call(self, ns, call):
        return f'{ns}::{call}'

    def _enum_class(self):
        return 'enum class'

    def _packets_by_block(self):
        return '::detail::packets_by_block'

    def _by_ref(self, value):
        return value

    def _initializer(self, struct):
        return ''
        
    def _constexpr(self, dtype):
        return f'constexpr {dtype}'
        
    def _str_len(self, string):
        return f'{string}.length()'

    def _public_inheritance(self, base):
        return f' : public {base}'

    def _global_structs(self):
        # CPP implementation does nothing here
        id_struct = (
            c.Statement(f'struct has_id'),
            c.Struct(
                'has_id',
                []
            )
        )
        
        vector_struct = (
            c.Statement(f'template <typename T> struct has_data_vector'),
            TemplateSemicolon('typename T', c.Struct(
                'has_data_vector',
                []
            ))
        )

        return (id_struct, vector_struct)
    
    def generate_message(self, main):
        message_name = main.name.eval()

        # Create struct
        decl, body = self._struct(WrapStruct, main)
        self.structs.forward.append(decl)
        self.structs.header.append(body)
        
        # Generate packer for the message
        decl, body, _ = self._packer(CppMethod, WrapPack, message_name, main.block)
        self.marshal.header.append(decl)
        self.marshal.source.append(body)

        # Unpacker
        decl, body,  _ = self._unpacker(CppMethod, WrapUnpack, message_name, main.block)
        self.marshal.header.append(decl)
        self.marshal.source.append(body)

    def generate_program(self, program, queues, messages):
        side = program.side.eval()
        program_name = program.name.eval()
        arguments = program.args.eval()
        print(arguments)

        assert side in ('CLIENT', 'SERVER', 'BROADCAST', 'BIDIRECTIONAL'), \
            f'Program `{program_name}` uses invalid side `{side}`, should be CLIENT, SERVER, BROADCAST or BIDIRECTIONAL'

        for message_name in arguments:
            assert self.is_message(message_name), f'Program `{program_name}` uses invalid type `{message_name}`'

        queue_name = self.user_defined_messages[arguments[0]].block.queue.identifier.eval()
        queue = queues[queue_name]
        queue_type = queue.specifier.queue_type
        
        if side in ('CLIENT', 'BIDIRECTIONAL'):
            # Make packet only when we have a single argument
            if len(arguments) == 1:
                _, body, _ = self._templated_make_packet(CppMethod, program_name, arguments[0])
                self.rpc_detail.header.append(body)

            # Templated queues (merger ones) don't have ack callbacks
            # TODO(gpascualg): Maybe here we should use has_callback()
            if queue.specifier.has_bare_send():
                decl, body, _ = self._server_s2c_from_packet(CppMethod, program_name, arguments, queue)
                self.rpc_detail.header.append(decl)
                self.rpc_detail.source.append(body)

                # Only single argument programs have detailed send methods
                if len(arguments) == 1:
                    _, body, _ = self._templated_server_s2c(CppMethod, program_name, arguments, queue)
                    self.rpc.header.append(body)
                
            elif len(arguments) == 1:
                header, body, _ = self._server_s2c(CppMethod, program_name, arguments, queue)
                self.rpc.header.append(header)
                self.rpc.source.append(body)

            # Same again but for broadcasts
            for postfix in ('', '_single'):
                # TODO(gpascualg): Maybe here we should use has_callback()
                if queue.specifier.has_bare_send():
                    decl, body, _ = self._broadcast_server_s2c_from_packet(CppMethod, program_name, arguments, postfix, queue)
                    self.rpc_detail.header.append(decl)
                    self.rpc_detail.source.append(body)

                    if len(arguments) == 1:
                        _, body, _ = self._broadcast_templated_server_s2c(CppMethod, program_name, arguments, postfix, queue)
                        self.rpc.header.append(body)
                elif len(arguments) == 1:
                    header, body, _ = self._broadcast_server_s2c(CppMethod, program_name, arguments, postfix, queue)
                    self.rpc.header.append(header)
                    self.rpc.source.append(body)

        if side in ('SERVER', 'BIDIRECTIONAL'):
            decl, body, _ = self._server_c2s(CppMethod, program_name, message_name)
            self.marshal.header.append(decl)
            self.marshal.source.append(body)

    def __generate_string_methods(self):
        declaration = c.FunctionDeclaration(
            c.Value('void', 'pack_string'),
            [
                self._data_object_ref(self._packet_type(), 'packet'),
                self._data_cref(self.get_dtype('string'), 'str')
            ]
        )

        body = c.FunctionBody(
            declaration,
            c.Block([
                c.Statement( 'uint8_t size = str.size()'),
                c.Statement(f'*packet << static_cast<uint8_t>(size)'),
                c.For(
                    'uint8_t i = 0', 'i < size', '++i',
                    c.Block([
                        c.Statement(f'*packet << static_cast<uint8_t>(str[i])')
                    ])
                )
            ])
        )
        
        self.marshal.header.append(declaration)
        self.marshal.source.append(body)

        declaration = c.FunctionDeclaration(
            c.Value('bool', 'unpack_string'),
            [
                self._pointer_type('PacketReader', 'packet'),
                self._data_object_ref(self.get_dtype('string'), 'str')
            ]
        )

        body = c.FunctionBody(
            declaration,
            c.Block([
                WrapUnpack._guard('sizeof(uint8_t)'),
                c.Statement( 'uint8_t size = packet->peek<uint8_t>()'),
                WrapUnpack._guard('size'),
                c.Statement(f'str = packet->read<std::string>()'),
                c.Statement('return true')
            ])
        )
        
        self.marshal.header.append(declaration)
        self.marshal.source.append(body)

    def _queue_var(self, name, queue):
        base = queue.base.subtype.eval()
        argument = '' if not queue.base.argument else queue.base.argument.eval()
        if argument:
            argument = f', {argument}'

        spec = queue.specifier
        name = f'_{name.lower()}'

        if spec.queue_type == QueueSpecifierType.STANDARD:
            return c.Value(f'{base}<immediate_packer{argument}>', name)
        
        if spec.queue_type == QueueSpecifierType.ARRAY:
            size = spec.args.eval()
            return c.Value(f'{base}<immediate_packer{argument}>', f'{name}[{size}]')

        if spec.queue_type == QueueSpecifierType.SPECIALIZED:
            packer = spec.args.eval()
            return c.Value(f'{base}<{packer}{argument}>', name)

        packer = ('unique_' if base == 'eventually_synced_queue' else '') + 'merge_packer'
        gtype = spec.args[0].eval()
        dtype = spec.args[1].eval()
        opcode = f'Opcode::OP_{self.get_opcode(spec.args[2].eval())}'
        return c.Value(f'{base}<{packer}<{gtype}, {dtype}, {opcode}>{argument}>', name)

    def _queue_decl(self, name, queue):
        name = f'_{name.lower()}'
        spec = queue.specifier

        if spec.queue_type == QueueSpecifierType.ARRAY:
            return [
                CppMethod('void', f'send{name}',
                    [self._data_cref(self._packet_type(), 'packet')],
                    c.Block([
                        c.Statement(f'{name}[slot].add(packet)')
                    ]),
                    ('int slot', 'slot')
                ),
                CppMethod('void', f'send{name}',
                    [
                        c.Value('Opcode', 'opcode'),
                        c.Value('T&&', 'data'),
                        c.Value('Args&&...', 'args')
                    ],
                    c.Block([
                        c.Statement(f'{name}[slot].add(opcode, std::forward<T>(data), std::forward<Args>(args)...)')
                    ]),
                    ('int slot, typename T, typename... Args', 'slot, T, Args...')
                )
            ]

        if spec.has_bare_send():
            return [
                CppMethod('void', f'send{name}',
                    [self._data_cref(self._packet_type(), 'packet')],
                    c.Block([
                        c.Statement(f'{name}.add(packet)')
                    ])
                ),
                CppMethod('void', f'send{name}',
                    [
                        c.Value('Opcode', 'opcode'),
                        c.Value('T&&', 'data'),
                        c.Value('Args&&...', 'args')
                    ],
                    c.Block([
                        c.Statement(f'{name}.add(opcode, std::forward<T>(data), std::forward<Args>(args)...)')
                    ]),
                    ('typename T, typename... Args', 'T, Args...')
                )
            ]

        return [
            CppMethod('void', f'send{name}',
                [
                    c.Value('Opcode', 'opcode'),
                    c.Value('T&&', 'data'),
                    c.Value('Args&&...', 'args')
                ],
                c.Block([
                    c.Statement(f'{name}.add(opcode, std::forward<T>(data), std::forward<Args>(args)...)')
                ]),
                ('typename T, typename... Args', 'T, Args...')
            )
        ]


    def _additional_queue_methods(self, queues):
        return [
            CppMethod('void', f'register_pools',
                [],
                c.Block([
                    c.Statement(f'decltype(_{name.lower()})::pool_t::allow()')
                    for name in queues.keys()
                ]),
                modifiers='static'
            )
        ]

    def _sizeof_message(self, Method, message_name, box, fname='message'):
        args = [
            self._data_cref(message_name, 'data')
        ]

        all_trivial = self._is_trivial(message_name, box)
        function_type = self.get_dtype('uint8')
        if all_trivial:
            function_type = self._constexpr(function_type)

        declaration = c.FunctionDeclaration(
            c.Value(function_type, f'{fname}_size'),
            args
        )

        if all_trivial:
            body = c.Block([
                c.Statement(f'return sizeof({message_name})')
            ])
        else:
            def get_dtype_size(decl):
                idl_dtype = decl.dtype.dtype.eval()
                variable = decl.name.eval()
                spec_type = None if not decl.dtype.spec else decl.dtype.spec.eval()
                return get_idl_dtype_size(idl_dtype, spec_type, variable, decl.optional)

            def get_idl_dtype_size(idl_dtype, spec_type, variable, optional):
                # Here goes all the sizes logic
                ret = col = c.Collection([])

                # Optional data is an special case
                if optional:
                    col.append(c.Statement('size += sizeof(bool)'))
                    inner = c.Block([])
                    col.append(c.If(f'static_cast<bool>(data.{variable})', inner))
                    col = inner

                dtype = self.get_dtype(idl_dtype)
                if self.is_trivial(idl_dtype):
                    col.append(c.Statement(f'size += sizeof({dtype})'))
                elif idl_dtype == 'string':
                    col.append(c.Statement(f'size += sizeof({self.get_dtype("uint8")}) + ' + self._str_len(f'data.{variable}')))
                elif self.is_message(idl_dtype):
                    col.append(c.Statement(f'size += {idl_dtype}_size(data.{variable})'))
                elif idl_dtype == 'vector':
                    if self.is_trivial(spec_type):
                        # TODO(gpascualg): No vector of optionals yet
                        col.append(c.Statement(f'size += sizeof({self.get_dtype("uint8")}) + data.{variable}.size() * {get_idl_dtype_size(spec_type, None, variable, None)}'))
                    elif self.is_message(spec_type):
                        if self._is_trivial(spec_type, self.user_defined_messages[spec_type]):
                            col.append(c.Statement(f'size += sizeof({self.get_dtype("uint8")}) + data.{variable}.size() * sizeof({spec_type})'))
                        else:
                            col.append(c.Collection([
                                c.Statement(f'size += sizeof({self.get_dtype("uint8")})'),
                                c.For('int i = 0', f'i < data.{variable}.size()', '++i', c.Block([
                                    c.Statement(f'size += {spec_type}_size(data.{variable}[i])')
                                ]))
                            ]))
                    elif spec_type == 'string':
                        raise NotImplementedError(f'Vector of strings is a WIP')
                    else:
                        raise NotImplementedError(f'Unsupported vector type {spec_type}')
                else:
                    raise NotImplementedError(f'Unrecognized type {idl_dtype}')

                return ret

            body = c.Block([
                c.Statement(f'{self.get_dtype("uint8")} size = 0'),
                *[get_dtype_size(decl) for decl in box.block.fields.eval()],
                c.Statement(f'return size')
            ])

        return (
            declaration,
            c.FunctionBody(declaration, body),
            Method(function_type, f'{fname}_size', args, body),
            all_trivial
        )

    def generate_queues(self, queues):
        # Queues class
        queue_cls = self._queues_class(CppClass, CppMethod, queues)
        self.queues.header.append(queue_cls)
        self.queues.source.append(queue_cls.source())

    def generate_common(self):
        # Common structs
        (id_forward, id_struct), (data_forward, data_struct) = self._global_structs()
        self.structs.forward.insert(0, id_forward)
        self.structs.forward.insert(0, data_forward)
        self.structs.header.insert(0, id_struct)
        self.structs.header.insert(0, data_struct)

        # Switch jump table
        decl, body, _ = self._jump_table(CppMethod)
        self.marshal.header.append(decl)
        self.marshal.source.append(body)

        # Opcodes enum
        self.opcodes.header.append(self._opcode_enum())
        
        # Language specific string methods
        self.__generate_string_methods()

        # Generate individual sizes
        for message_name, message in self.user_defined_messages.items():
            header, body, _, all_trivial = self._sizeof_message(CppMethod, message_name, message, fname=message_name)
            self.marshal.forward.append(header)

            if all_trivial:
                self.marshal.header.append(body)
            else:
                self.marshal.source.append(body)

        # Big size switch
        body = c.FunctionBody(c.Template('typename T', c.FunctionDeclaration(c.Value('inline uint8_t', 'message_size'),
            [
                self._data_cref('T', 'message')
            ]
        )), c.Block([
            c.Collection([
                c.Line(('' if i == 0 else 'else ') + f'if constexpr (std::is_same_v<std::decay_t<T>, {message_name}>)'),
                c.Block([
                    c.Statement(f'return {message_name}_size(message)')
                ])
            ]) for i, message_name in enumerate(self.user_defined_messages)
        ]))

        self.marshal.header.append(body)

        # Big pack switch
        body = c.FunctionBody(c.Template('typename T', c.FunctionDeclaration(c.Value('inline void', 'pack_message'),
            [
                self._data_object_ref(self._packet_type(), 'packet'),
                c.Value('T&&', 'message')
            ]
        )), c.Block([
            c.Collection([
                c.Line(('' if i == 0 else 'else ') + f'if constexpr (std::is_same_v<std::decay_t<T>, {message_name}>)'),
                c.Block([
                    c.Statement(f'pack_{message_name}(packet, std::forward<T>(message))')
                ])
            ]) for i, message_name in enumerate(self.user_defined_messages)
        ]))

        self.marshal.header.append(body)

    def dump(self, path):
        header, _ = self.structs.dump(
            [
                '#include <inttypes.h>',
                '#include <optional>',
                '#include <string>',
                '#include <vector>'
            ],
            []
        )
        with open(os.path.join(path, 'structs.hpp'), 'w') as fp:
            fp.write(str(header))

        header, source = self.rpc.dump(
            [
                '#include <inttypes.h>',
                '#include <optional>',
                '#include <vector>',
                '#include "network/autogen/opcodes.hpp"',
                '#include "network/autogen/structs.hpp"',
                '#include "network/autogen/rpc_detail.hpp"',
                '#include "network/autogen/marshal.hpp"',
                '#include "network/buffers/packet.hpp"',
                '#include "network/buffers/packet_reader.hpp"',
                '#include <cppcoro/sync_wait.hpp>',
                'class Cell;',
                'class Client;'
            ],
            [
                '#include "network/autogen/rpc.hpp"',
                '#include "map/cell.hpp"',
                '#include "server/client.hpp"',
                'extern inline SuperPacket* get_superpacket(Client* client);'
            ]
        )
        with open(os.path.join(path, 'rpc.hpp'), 'w') as fp:
            fp.write(str(header))

        with open(os.path.join(path, 'rpc.cpp'), 'w') as fp:
            fp.write(str(source))

        header, source = self.rpc_detail.dump(
            [
                '#include <inttypes.h>',
                '#include <optional>',
                '#include <vector>',
                '#include "network/autogen/opcodes.hpp"',
                '#include "network/autogen/structs.hpp"',
                '#include "network/autogen/rpc_detail.hpp"',
                '#include "network/autogen/marshal.hpp"',
                '#include "network/buffers/packet.hpp"',
                '#include "network/buffers/packet_reader.hpp"',
                '#include <cppcoro/sync_wait.hpp>',
                'class Cell;',
                'class Client;'
            ],
            [
                '#include "network/autogen/rpc_detail.hpp"',
                '#include "map/cell.hpp"',
                '#include "server/client.hpp"',
                'extern inline SuperPacket* get_superpacket(Client* client);'
            ]
        )
        with open(os.path.join(path, 'rpc_detail.hpp'), 'w') as fp:
            fp.write(str(header))

        with open(os.path.join(path, 'rpc_detail.cpp'), 'w') as fp:
            fp.write(str(source))

        header, source = self.marshal.dump(
            [
                '#include <inttypes.h>',
                '#include <optional>',
                '#include <vector>',
                '#include "network/autogen/structs.hpp"',
                '#include "network/buffers/packet.hpp"',
                '#include "network/buffers/packet_reader.hpp"',
                'class Client;'
            ],
            [
                '#include "network/autogen/marshal.hpp"',
                '#include "network/autogen/opcodes.hpp"',
                '#include "network/autogen/rpc.hpp"',
                '#include "server/client.hpp"'
            ]
        )
        with open(os.path.join(path, 'marshal.hpp'), 'w') as fp:
            fp.write(str(header))

        with open(os.path.join(path, 'marshal.cpp'), 'w') as fp:
            fp.write(str(source))
        
        header, source = self.queues.dump(
            [
                '#include <inttypes.h>',
                '#include <optional>',
                '#include <vector>',
                '#include <cppcoro/task.hpp>',
                '#include "network/buffers/packet.hpp"',
                '#include "network/buffers/packet_reader.hpp"',
                '#include "network/queues/reliable_queue.hpp"',
                '#include "network/queues/unreliable_queue.hpp"',
                '#include "network/queues/eventually_synced_queue.hpp"',
                '#include "network/packers/immediate_packer.hpp"',
                '#include "network/packers/ordered_packer.hpp"',
                '#include "network/packers/merge_packer.hpp"',
                '#include "network/packers/unique_merge_packer.hpp"',
                '#include "network/packers/most_recent_packer_with_id.hpp"',
                '#include "network/packers/most_recent_packer_by_opcode.hpp"',
            ],
            [
                '#include "network/autogen/queues.hpp"',
            ]
        )
        with open(os.path.join(path, 'queues.hpp'), 'w') as fp:
            fp.write(str(header))

        with open(os.path.join(path, 'queues.cpp'), 'w') as fp:
            fp.write(str(source))

        header, _ = self.opcodes.dump(
            [
                '#include <inttypes.h>',
            ],
            []
        )
        with open(os.path.join(path, 'opcodes.hpp'), 'w') as fp:
            fp.write(str(header))
