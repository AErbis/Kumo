from .boxes import *
from .boxes_csharp import *
from .generator import Generator

import os
import cgen as c



WARNING = """
    This file is autogenerated via IDL, DO NOT modify it directly
    All changes will be overwritten, modify .idl files instead

"""

class File(object):
    def __init__(self, namespace=['Argentum.Network.Rpc']):
        self.header = c.Block()
        self.forward = c.Block()
        self.source = c.Block()
        self.namespace = namespace

    def ns(self, parent):
        ns = c.Collection([c.Line(f'namespace {self.namespace[0]}')])
        parent.append(ns)

        if len(self.namespace) > 1:
            block = c.Block([
                c.Line(f'class {self.namespace[1]}')
            ])
            ns.append(block)
            return block

        return parent

    def dump(self, forward, source_includes, no_forward=False):
        header = c.Collection(
            [c.MultilineComment(WARNING)] + 
            [c.Line(x) for x in forward]
        )
        ns = self.ns(header)

        if not no_forward and self.forward.contents:
            ns.append(self.forward)
            ns = self.ns(header)
        
        ns.append(self.header)
        
        source = c.Collection(
            [c.MultilineComment(WARNING)] + 
            [c.Line(x) for x in source_includes]
        )
        ns = self.ns(source)
        ns.append(self.source)
        return header, source


class CSharpGenerator(Generator):
    def __init__(self, *args):
        super(CSharpGenerator, self).__init__(*args)

        self.TRIVIAL_TYPES['int8'] = 'char'
        self.TRIVIAL_TYPES['int16'] = 'short'
        self.TRIVIAL_TYPES['int32'] = 'int'
        self.TRIVIAL_TYPES['int64'] = 'long'
        self.TRIVIAL_TYPES['uint8'] = 'byte'
        self.TRIVIAL_TYPES['uint16'] = 'ushort'
        self.TRIVIAL_TYPES['uint32'] = 'uint'
        self.TRIVIAL_TYPES['uint64'] = 'ulong'
        self.TRIVIAL_TYPES['float'] = 'float'
        self.TRIVIAL_TYPES['double'] = 'double'
        self.TRIVIAL_TYPES['bool'] = 'bool'
        self.VALID_TYPES['string'] = 'string'
        self.VALID_TYPES['vector'] = 'List'

        self.structs = File()
        self.rpc = File()
        self.rpc_detail = File()
        self.marshal = File()
        self.queues = File()
        self.opcodes = File()

        self.all_packers = []
        self.all_methods = []
        self.all_detail_methods = []

    def _packet_type(self):
        return 'Packet'

    def _data_cref(self, dtype, name):
        return c.Value(dtype, name)

    def _pointer_type(self, dtype, name):
        return c.Value(dtype, name)

    def _data_object_ref(self, dtype, name):
        return c.Value(dtype, name)

    def _data_value_ref(self, dtype, name):
        return c.Value(f'ref {dtype}', name)

    def _template_call(self, name, arg):
        return f'{name}<{arg}>'

    def _template_function_declaration(self, template, body):
        return body

    def _template_function_name(self, template, name):
        return f'{name}<{template}>'

    def _template_function_arg(self, dtype, name, default=''):
        return c.Value(dtype, f'{name}{default}')

    def _template_forward(self, template, name):
        return name

    def _call_queue(self, queue, args):
        args = ', '.join(args)
        name = f'_{queue.name.eval().lower()}'

        if queue.specifier.queue_type == QueueSpecifierType.ARRAY:
            idx = queue.specifier.args.eval()
            return f'client.Superpacker.send{name}({idx}, {args})'

        return f'client.Superpacket.send{name}({args})'

    def _pointer_call(self, obj, call):
        return f'{obj}.{call}'

    def _ns_call(self, ns, call):
        return f'{ns}.{call}'

    def _enum_class(self):
        return 'public enum'

    def _packets_by_block(self):
        return 'SortedDictionary<uint, List<Packet>>'

    def _by_ref(self, value):
        return f'ref {value}'

    def _initializer(self, struct):
        return f' = new {struct}()'

    def _constexpr(self, dtype):
        return dtype

    def _str_len(self, string):
        return f'{string}.Length'

    def _public_inheritance(self, base):
        return f' : {base}'
    
    def _global_structs(self):
        id_struct = (
            c.Statement(f'struct has_id : IData'),
            CSharpClass(
                'has_id : IData',
                [
                    CSharpMethod('abstract ulong', 'get_id', [], None),
                    CSharpMethod('abstract void', 'set_id', [c.Value('ulong', 'id_')], None),
                ], [], [],
                [], [], [], True,
                visibility='public abstract'
            )
        )
        
        vector_struct = (
            c.Statement(f'struct has_data_vector<T> : IData'),
            CSharpClass(
                'has_data_vector<T> : IData',
                [
                    CSharpMethod('abstract List<T>', 'get_data', [], None),
                    CSharpMethod('abstract void', 'init', [], None),
                ], [], [],
                [], [], [], True,
                visibility='public abstract'
            )
        )
        
        idata_struct = (
            c.Statement(f'struct IData'),
            CSharpClass(
                'IData',
                [
                    CSharpMethod('abstract void', 'pack', [c.Value('Packet', 'packet')], None),
                    CSharpMethod('abstract byte', 'size', [], None),
                ], [], [],
                [], [], [], True,
                visibility='public abstract'
            )
        )

        return (id_struct, vector_struct, idata_struct)

    def generate_message(self, main):
        message_name = main.name.eval()

        # Create struct
        decl, body = self._struct(WrapStruct, main)
        self.structs.forward.append(decl)
        self.structs.header.append(body)
        
        # Generate packer for the message
        _, _, method = self._packer(CSharpMethod, WrapPack, message_name, main.block)
        self.all_packers.append(method.modifier('static'))

        _, _, method = self._generic_packer(CSharpMethod, WrapPack, message_name, main.block)
        self.all_packers.append(method.modifier('static'))

        # Unpacker
        _, _, method = self._unpacker(CSharpMethod, WrapUnpack, message_name, main.block)
        self.all_packers.append(method.modifier('static'))

    def generate_program(self, program, queues, messages):
        side = program.side.eval()
        program_name = program.name.eval()
        arguments = program.args.eval()
        print(arguments)

        assert side in ('CLIENT', 'SERVER', 'BROADCAST', 'BIDIRECTIONAL'), \
            f'Program `{program_name}` uses invalid side `{side}`, should be CLIENT, SERVER, BROADCAST or BIDIRECTIONAL'

        for message_name in arguments:
            assert self.is_message(message_name), f'Program `{program_name}` uses invalid type `{message_name}`'
        
        queue_name = self.user_defined_messages[arguments[0]].block.queue.identifier.eval()
        queue = queues[queue_name]
        queue_type = queue.specifier.queue_type

        if side in ('SERVER', 'BIDIRECTIONAL'):
            if len(arguments) == 1:
                _, _, method = self._make_packet(CSharpMethod, program_name, arguments[0], 'Packet.AckCallback', '=null')
                self.all_detail_methods.append(method.modifier('static'))

            if queue.specifier.has_callback():
                if queue.specifier.has_bare_send():
                    _, _, method = self._server_s2c_from_packet(CSharpMethod, program_name, arguments, queue)
                    self.all_detail_methods.append(method.modifier('static'))

                if len(arguments) == 1:
                    _, _, method = self._server_s2c(CSharpMethod, program_name, arguments, queue, 'Packet.AckCallback', '=null')
                    self.all_methods.append(method.modifier('static'))

            elif len(arguments) == 1:
                _, _, method = self._server_s2c(CSharpMethod, program_name, arguments, queue)
                self.all_methods.append(method)

            # NO BROADCAST IN CSHARP YET

        if side in ('CLIENT', 'BIDIRECTIONAL'):
            if len(arguments) == 1:
                # FIXME(gpascualg): Find actual queue and global struct in a smarter way
                msg = messages[message_name]
                queue = queues[msg.block.queue.identifier.eval()]
                if queue.specifier.queue_type == QueueSpecifierType.TEMPLATED:
                    message_name = queue.specifier.args[0].eval()
                
                _, _, method = self._server_c2s(CSharpMethod, program_name, message_name)
                self.all_packers.append(method.modifier('static'))

    def __generate_string_methods(self):
        body = c.Block([
            c.Statement( 'byte size = (byte)str.Length'),
            c.Statement(f'packet.Data.WriteInt8(size)'),
            c.For(
                'byte i = 0', 'i < size', '++i',
                c.Block([
                    c.Statement(f'packet.Data.WriteByte((byte)str[i])')
                ])
            )
        ])

        self.all_packers.append(CSharpMethod(
            'void', 'pack_string',
            [
                self._data_object_ref(self._packet_type(), 'packet'),
                self._data_cref(self.get_dtype('string'), 'str')
            ],
            body
        ).modifier('static'))

        body = c.Block([
            WrapUnpack._guard('sizeof(byte)'),
            c.Statement( 'byte size = packet.Data.ReadUInt8(packet.Data.Size)'),
            WrapUnpack._guard('size'),
            c.Statement(f'str = packet.Data.ReadString()'),
            c.Statement('return true')
        ])

        self.all_packers.append(CSharpMethod(
            'bool', 'unpack_string',
            [
                self._pointer_type('PacketReader', 'packet'),
                self._data_value_ref(self.get_dtype('string'), 'str')
            ],
            body
        ).modifier('static'))

    def _queue_var(self, name, queue):
        base = queue.base.subtype.eval()
        argument = '' if not queue.base.argument else queue.base.argument.eval()
        if argument:
            argument = f'{argument}'
        
        spec = queue.specifier
        name = f'_{name.lower()}'

        if spec.queue_type == QueueSpecifierType.STANDARD:
            return c.Value(f'{base}<immediate_packer, Packet>', f'{name} = new {base}<immediate_packer, Packet>({argument})')

        if spec.queue_type == QueueSpecifierType.ARRAY:
            # TODO(gpascualg): Arguments won't work inside arrays
            # TODO(gpascualg): Inner objects in C# queues are never constructed
            size = spec.args.eval()
            return c.Value(f'{base}<immediate_packer, Packet>', f'{name}[{size}] = new {base}<immediate_packer, Packet>[{size}]')

        if spec.queue_type == QueueSpecifierType.SPECIALIZED:
            packer = spec.args.eval()

            postfix = ''
            if packer.find('with_id') > 0:
                postfix = '_with_id'
            elif packer.find('by_opcode') > 0:
                postfix = '_by_opcode'

            if postfix:
                return c.Value(f'{base}{postfix}<{packer}>', f'{name} = new {base}{postfix}<{packer}>({argument})')

            return c.Value(f'{base}<{packer}, Packet>', f'{name} = new {base}<{packer}, Packet>({argument})')
    
        packer = ('unique_' if base == 'eventually_synced_queue' else '') + 'merge_packer'
        gtype = spec.args[0].eval()
        dtype = spec.args[1].eval()
        # TODO(gpascualg): Set opcode somewhere
        opcode = f'Opcode.OP_{self.get_opcode(spec.args[2].eval())}'
        return c.Value(f'{base}<{packer}<{gtype}, {dtype}>, {dtype}>', f'{name} = new {base}<{packer}<{gtype}, {dtype}>, {dtype}>({argument})')

    def _queue_decl(self, name, queue):
        original_queue_name = name
        name = f'_{name.lower()}'
        spec = queue.specifier

        if spec.queue_type == QueueSpecifierType.ARRAY:
            return [
                CSharpMethod('void', f'send{name}',
                    [
                        c.Value('int', 'slot'),
                        self._data_cref(self._packet_type(), 'packet')
                    ],
                    c.Block([
                        c.Statement(f'{name}[slot].add(packet)')
                    ])
                ),
                CSharpMethod('void', f'send{name}',
                    [
                        c.Value('int', 'slot'),
                        c.Value('Opcode', 'opcode'),
                        c.Value('T', 'data'),
                        c.Value('Packet.AckCallback', 'callback')
                    ],
                    c.Block([
                        c.Statement(f'{name}[slot].add(opcode, data, callback)')
                    ]),
                    ('typename T', 'T')
                ).where('T : IData')
            ]

        if spec.has_bare_send():
            return [
                CSharpMethod('void', f'send{name}',
                    [self._data_cref(self._packet_type(), 'packet')],
                    c.Block([
                        c.Statement(f'{name}.add(packet)')
                    ])
                ),
                CSharpMethod('void', f'send{name}',
                    [
                        c.Value('Opcode', 'opcode'),
                        c.Value('T', 'data'),
                        c.Value('Packet.AckCallback', 'callback')
                    ],
                    c.Block([
                        c.Statement(f'{name}.add(opcode, data, callback)')
                    ]),
                    ('typename T', 'T')
                ).where('T : IData')
            ]

        if spec.queue_type == QueueSpecifierType.SPECIALIZED:
            return [
                CSharpMethod('void', f'send{name}',
                    [
                        c.Value('Opcode', 'opcode'),
                        c.Value(msg.name.eval(), 'data'),
                        c.Value('Packet.AckCallback', 'callback')
                    ],
                    c.Block([
                        c.Statement(f'{name}.add(opcode, data, callback)')
                    ])
                )

                for msg in self.user_defined_messages.values() if msg.block.queue.identifier.eval() == original_queue_name
            ]
            
        data_type = spec.args[1].eval()
        return [
            CSharpMethod('void', f'send{name}',
                [
                    c.Value('Opcode', 'opcode'),
                    c.Value(data_type, 'data'),
                    c.Value('Packet.AckCallback', 'callback')
                ],
                c.Block([
                    c.Statement(f'{name}.add(opcode, data, callback)')
                ])
            )
        ]

    def _sizeof_message(self, Method, message_name, box, fname='message'):
        args = [
            self._data_cref(message_name, 'data')
        ]

        all_trivial = self._is_trivial(message_name, box, include_messages=False)
        function_type = self.get_dtype('uint8')
        if all_trivial:
            function_type = self._constexpr(function_type)

        declaration = c.FunctionDeclaration(
            c.Value(function_type, f'{fname}_size'),
            args
        )

        if all_trivial:
            sizes = ' + '.join(f'sizeof({self.get_dtype(decl.dtype.dtype.eval())})' for decl in box.block.fields.eval())
            if not sizes:
                sizes = '0'

            body = c.Block([
                c.Statement(f'return {sizes}')
            ])
        else:
            def get_dtype_size(decl):
                idl_dtype = decl.dtype.dtype.eval()
                variable = decl.name.eval()
                spec_type = None if not decl.dtype.spec else decl.dtype.spec.eval()
                return get_idl_dtype_size(idl_dtype, spec_type, variable, decl.optional)

            def get_idl_dtype_size(idl_dtype, spec_type, variable, optional):
                # Here goes all the sizes logic
                ret = col = c.Collection([])

                # Optional data is an special case
                if optional:
                    col.append(c.Statement('size += sizeof(bool)'))
                    inner = c.Block([])
                    col.append(c.If(f'data.{variable}.HasValue', inner))
                    col = inner

                dtype = self.get_dtype(idl_dtype)
                if self.is_trivial(idl_dtype):
                    col.append(c.Statement(f'size += sizeof({dtype})'))
                elif idl_dtype == 'string':
                    col.append(c.Statement(f'size += (byte)(sizeof({self.get_dtype("uint8")}) + ' + self._str_len(f'data.{variable}') + ')'))
                elif self.is_message(idl_dtype):
                    col.append(c.Statement(f'size += {idl_dtype}_size(data.{variable})'))
                elif idl_dtype == 'vector':
                    if self.is_trivial(spec_type):
                        # TODO(gpascualg): No vector of optionals yet
                        col.append(c.Statement(f'size += (byte)(sizeof({self.get_dtype("uint8")}) + data.{variable}.Count * {get_idl_dtype_size(spec_type, None, variable, None)})'))
                    elif self.is_message(spec_type):
                        if self._is_trivial(spec_type, self.user_defined_messages[spec_type], include_messages=False):
                            col.append(c.Collection([
                                c.If(f'data.{variable}.Count == 0',
                                    c.Block([c.Statement(f'size += sizeof({self.get_dtype("uint8")})')]),
                                    c.Block([c.Statement(f'size += (byte)(sizeof({self.get_dtype("uint8")}) + data.{variable}.Count * {spec_type}_size(data.{variable}[0]))')])
                                )
                            ]))
                        else:
                            col.append(c.Collection([
                                c.Statement(f'size += sizeof({self.get_dtype("uint8")})'),
                                c.For('int i = 0', f'i < data.{variable}.Count', '++i', c.Block([
                                    c.Statement(f'size += {spec_type}_size(data.{variable}[i])')
                                ]))
                            ]))
                    elif spec_type == 'string':
                        raise NotImplementedError(f'Vector of strings is a WIP')
                    else:
                        raise NotImplementedError(f'Unsupported vector type {spec_type}')
                else:
                    raise NotImplementedError(f'Unrecognized type {idl_dtype}')

                return ret

            body = c.Block([
                c.Statement(f'{self.get_dtype("uint8")} size = 0'),
                *[get_dtype_size(decl) for decl in box.block.fields.eval()],
                c.Statement(f'return size')
            ])

        return (
            declaration,
            c.FunctionBody(declaration, body),
            Method(function_type, f'{fname}_size', args, body),
            all_trivial
        )

    def generate_queues(self, queues):
        # Queues class
        queues_cls = self._queues_class(CSharpClass, CSharpMethod, queues)
        self.queues.source.append(queues_cls)

    def generate_common(self):
        # Common structs
        (_, id_struct), (_, data_struct), (_, idata_struct) = self._global_structs()
        self.structs.header.insert(0, id_struct)
        self.structs.header.insert(0, data_struct)
        self.structs.header.insert(0, idata_struct)

        # Switch jump table
        _, _, method = self._jump_table(CSharpMethod, skip_status_check=True)
        self.all_packers.append(method.modifier('static'))

        # Opcodes enum
        self.opcodes.header.append(self._opcode_enum())
        
        # Language specific string methods
        self.__generate_string_methods()

        # Individual sizes
        for message_name, message in self.user_defined_messages.items():
            _, _, method, _ = self._sizeof_message(CSharpMethod, message_name, message, fname=message_name)
            self.all_packers.append(method.modifier('static'))

            _, _, method, _ = self._sizeof_message(CSharpMethod, message_name, message)
            self.all_packers.append(method.modifier('static'))

        # Group all methods
        rpc = CSharpClass('rpc', self.all_methods, [], [], [], [], [])
        self.rpc.source.append(rpc)

        rpc_detail = CSharpClass('detail', self.all_detail_methods, [], [], [], [], [])
        self.rpc_detail.source.append(rpc_detail)

        # Group all packers
        packers = CSharpClass('marshal', self.all_packers, [], [], [], [], [])
        self.marshal.source.append(packers)

    def dump(self, path):
        header, _ = self.structs.dump(
            [
                'using System;',
                'using System.Collections.Generic;'
            ],
            [],
            no_forward=True
        )
        with open(os.path.join(path, 'structs.cs'), 'w') as fp:
            fp.write(str(header))

        header, source = self.rpc.dump(
            [],
            [
                'using System;',
                'using System.Collections.Generic;'
            ]
        )
        with open(os.path.join(path, 'rpc.cs'), 'w') as fp:
            fp.write(str(source))

        header, source = self.rpc_detail.dump(
            [],
            [
                'using System;',
                'using System.Collections.Generic;'
            ]
        )
        with open(os.path.join(path, 'rpc_detail.cs'), 'w') as fp:
            fp.write(str(source))

        header, source = self.marshal.dump(
            [],
            [
                'using System;',
                'using System.Collections.Generic;'
            ]
        )
        with open(os.path.join(path, 'marshal.cs'), 'w') as fp:
            fp.write(str(source))
        
        header, source = self.queues.dump(
            [],
            [
                'using System;',
                'using System.Collections.Generic;',
                'using Argentum.Network;'
            ]
        )
        with open(os.path.join(path, 'queues.cs'), 'w') as fp:
            fp.write(str(source))

        header, _ = self.opcodes.dump(
            [],
            []
        )
        with open(os.path.join(path, 'opcodes.cs'), 'w') as fp:
            fp.write(str(header))

